 # I Wanna Cry

 ### Challenge

```
Oh no! My friend got hit by a nasty ransomware called AESLocker. Now, all his files (even his final paper) are encrypted!

Can you decrypt the files for him?

[](/media/encrypted_files.zip)
[](/media/aeslocker.py)

```



### Description
The challenge provides a ZIP file containing encrypted files with the extension `.enc`. To find the flag, the user must decrypt the file `flag.txt.enc`. From the provided encryption code, the team identified that the encryption uses AES in CTR mode. Additionally, since we have a plaintext-ciphertext pair from `aeslocker.py` and `aeslocker.py.enc`, then it's possible to XOR the given pair with the ciphertext flag to decrypt it and get the plaintext. 

### Insight
The AESLocker ransomware is a Python script that encrypts all files in a folder using the AES-CTR mode `Cipher(algorithms.AES(key), modes.CTR(nonce))`. Once the ransomware is executed, it replaces the data inside each file with the ciphertext. After replacing the data in the first file, the counter increases by 1; then the script repeats the encryption until all files in a folder are encrypted.

Advanced Encryption Standard-Counter Mode (AES-CTR) "essentially turns a block cipher into a stream cipher." [CSCI 184.03 Lecture 9: Block Ciphers](https://drive.google.com/file/d/1CEkPcD5KGI_STxjm7OrpkUIDssjM-gpC/view). Encryption using the CTR mode uses a keystream created from two values (key and nonce) then XOR'ed with the plaintext.  

> "The keystream block is generated by $K_i \coloneqq Enc_k(N || ctr +i)$ and encryption is done by ciphertext $C_i \coloneqq P_i \oplus K_i$."

The figure [(CSCI 184.03 Lecture 9: Block Ciphers)](https://drive.google.com/file/d/1CEkPcD5KGI_STxjm7OrpkUIDssjM-gpC/view) below illustrates how encryption works in AES-CTR:
![[Pasted image 20220525131347.png]]

The challenge provides a ZIP file containing the encrypted files. One of the encrypted files is the actual ransomware script `aeslocker.py.enc`, and since we have the contents of the script `aeslocker.py`, we can use these two as the ciphertext-plaintext pair to get the keystream block. 

We can exploit that the script contains an **IV and the key that are generated only *once* in encrypting each file.** Therefore, it's possible to XOR two ciphertext to get the plaintexts. 
$$C_{1} \oplus C_2 = P_1 \oplus K \oplus P_2 \oplus K$$

Then, since we have a ciphertext-plaintext pair, we can XOR these with the ciphertext flag to get the plaintext flag. 
$$P_2 = C_{1} \oplus C_2 \oplus P_1$$


### Solution
As explained in the Insight section, we can XOR $C_1$, $C_2$, $P_1$ to get $P_2$. In the case of the challenge:
- $C_1 \coloneqq$ `aeslocker.py.enc` $\coloneqq$ `aes_c
- $P_1 \coloneqq$ `aeslocker.py` = $\coloneqq$ `aes_p`
- $C_2 \coloneqq$ `flag.txt.enc` $\coloneqq$ `flag_c`
- $P_2 \coloneqq$ `flag.txt` $\coloneqq$ `flag_p`


Since the script uses AES-CTR mode with the key length and nonce length of 16 bytes, the encryption is also done by 16-byte blocks. After the encryption of each file, the value of IV is incremented by 1.  

To create the blocks, we use the code below provided from one of the homeworks:
```python
def create_blocks(enc, n):
Â  Â  blocks = []
Â  Â  for i in range(0,len(enc),n):
Â  Â  Â  Â  blocks.append(enc[i:i+n])
Â  Â  return blocks
```

Then we split the ciphertexts and plaintexts using the `create_blocks` function:
```python
aes_p = create_blocks(open('aeslocker.py', 'rb').read(),16)
aes_c = create_blocks(open('aeslocker.py.enc', 'rb').read(),16)
flag_c = create_blocks(open('flag.txt.enc', 'rb').read(),16)
```

As mentioned in the Insight part, the plaintext flag can be generated using the XOR of the `aeslocker.py` plaintext and ciphertext pair, and the `flag.txt.enc` ciphertext. 

```python
# since 
flag_p[0] ^ flag_c[0] = aes_p[count] ^ aes_c[count]
# therefore: 
flag_p[0] = aes_p[count] ^ aes_c[count] ^ flag_c[0]
```

And since there are four files, the only possible increment (`count`) is upto 3. 

![[Pasted image 20220525134146.png]]

```python
for count in [1, 2, 3]:
Â  Â  result = ''
Â  Â  for i in range(len(flag_c)):
Â  Â  Â  Â  xor_aes = xor_bytes(aes_p[i + count], aes_c[i + count]) # keystream
Â  Â  Â  Â  xor_flag = xor_bytes(flag_c[i],xor_aes) # keystream xor flag_c
Â  Â  Â  Â  result += ''.join(map(chr, xor_flag))
Â  Â  print(count, ' - ', result)
```

Once we execute the code, it will return 3 lines, and one of those lines return the flag. 
```python
1 - (Ã¿Ã ÂªÂ·Â»Ã™Ã»}Â‡Ã‹4rÃ”Ã”Ã°<Ãœ-Â®)Ã¥Ã¹$HÂ‰ÃÃ€kGpÂ˜SÃ£Ã˜Â‡lÃ‚Â—Â“ 
2 - Ã¿Â‚ÃÃ²$ÂŒÂ†ÂŸgÃ•Ã³CgÂ¶ÃŽZK|hÂŸ~U${KD}Ãµ?Oj49Ã®Ã¨ÂÃŠÂ¨Â¥ 
3 - CSCI_184.03_CTF{n0nc3_r3us3__str1ke5_y3t_4g41n!}
```


### Final answer 
`CSCI_184.03_CTF{n0nc3_r3us3__str1ke5_y3t_4g41n!}`